/*
 *  Copyright (C) 2016 TUB (www.tu-berlin.de), Author: Alvaro Ortiz
 *
 *  This file is part of Math for Refugees
 *  (see www.math4refugees.de).
 *  Forked from mintscripts.js by Daniel Haase (www.kit.edu)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 * */

// Ueberbleibsel aus parser.js
function extround(zahl,n_stelle)
{
    var i;
    i = Math.pow(10,n_stelle);
    zahl = (Math.round(zahl * i) / i);
    return zahl;
}

// parses math going from the user to course internals, course will always process math in unotation
function notationParser_IN(s) {

    // Von der Koordinierungsgruppe beschlossene OMB+ Notation
    if (variant == "std") {
        s = s.replace(/\,/g,"."); // std -> unotation: decimal point instead of comma
        s = s.replace(/\;/g,","); // std -> unotation: comma instead of semicolon
    }

    // Am Ende haengende Verketter ^ und _ nicht an Parser weitergeben
    if (s.lastIndexOf("^") == (s.length - 1)) s = s.slice(0,s.length-1);
    if (s.lastIndexOf("_") == (s.length - 1)) s = s.slice(0,s.length-1);

    // replace HTML tags which show up if the user used copy&paste from the webpage
    s.replace(/&nbsp;/g," ");
    s.replace(/\t/g," ");

    return s;

}

// parses math going from course internals to the user, course will always process math in unotation
function notationParser_OUT(s) {
    // inverse of notationParser_IN except HTML tag treatment which cannot occur here

    if (variant == "std") {
        s = s.replace(/\,/g,";");
        s = s.replace(/\\right\./g,"\\right\\DOTESCAPE"); // Quick&Dirty-workaround fuer Dezimalpunktreplacement
        s = s.replace(/\./g,",");
        s = s.replace(/\\right\\DOTESCAPE/g,"\\right\."); // Quick&Dirty-workaround fuer Dezimalpunktreplacement
    }

    return s;
}

function mygcd(a, b) {
  if (!b) { return a; }
  return mygcd(b, a % b);
}

function getIndeterminatePropName() {
    /**
    Workaround for Firefox Bug https://bugzilla.mozilla.org/show_bug.cgi?id=1281733

    Use 'readOnly' instead of 'indeterminate', otherwise Firefox (on Linux)
    will mess up the tristate checkbox display (however the values are correct).
    **/
    var isFirefox = /Firefox/i.test( navigator.userAgent );
    return isFirefox? 'readOnly' : 'indeterminate';
}

// Erzeugt das zu einem interaktiven Fragefeld gehoerende JS-Objekt
// uxid = unique exercise id zur Verwendung mit intersite.getObj()
// c = Wert der Zaehlers MFieldCounter aus tex-Dokument
// solution = Loesung (Typ der Loesung abhaengig vom Typ der Aufgabe, aber immer string)
// id = alphanumerische id des Aufgaben-Elements (Eindeutig in html-file)
// type = Typnummer der Aufgabe wie in mintmod.tex beschrieben
// option = Optionsstring, ggf. Einzelstrings durch Semikolon getrennt
// points = Erreichbare Punktzahl der Aufgabe
// section = entsprechender counter aus texfile
function CreateQuestionObj(uxid, c, solution, id, type, option, pnts, intest, section) {

  // Durch ttm geschleuste Loesungsformeln entparsen falls ttm Sonderzeichen als HTML-Code codiert hat

  solution = solution.replace(/\&amp;/g,"&");
  solution = solution.replace(/\&\#38;/g,"&");
  solution = solution.replace(/\&\#166;/g,"|");
  solution = solution.replace(/\&\#60;/g,"<");
  solution = solution.replace(/\&\#62\;/g,">");
  solution = solution.replace(/\&lt\;/g,"<");
  solution = solution.replace(/\&gt\;/g,">");

  // Umlauts, {, } and \ss will be given in unicode

  ob = Object.create(null);
  ob.counter = c;
  ob.id = id;

  if (uxid.indexOf("AUTOGENERATED") != -1) {
    ob.sync = 0; // Aufgabe wird nicht synchronisiert, nicht geloggt und Punktezahl nicht gewertet (z.B. fuer autogenerierte Trainingsaufgaben)
  } else {
    ob.sync = 1;
  }

  if (type == 2) {
    if (solution.indexOf("::smc") != -1) {
        var sm = solution.substr(solution.indexOf("::smc") + 5, solution.length - solution.indexOf("::smc") - 5);
        solution = solution.substr(0, solution.indexOf("::smc"));
        ob.smc = sm.split(",");
        ob.imgid = null; // SMC-Boxen erhalten keine Loesungsfelder
    } else {
        ob.smc = new Array(); // Leeres Array aus auszuschliessenden Checkboxen
        ob.imgid = option; // Einzelboxen erhalten Loesungsfelder
    }
  } else {
    ob.imgid = "QM" + ob.id;
  }


  if ((type == 6) || (type == 7)) {
    // Intervalle und Spezialaufgaben haben Loesungscode fuer linke und rechte Grenze, und Semikolons werden durch Kommata ersetzt.
    ob.solution = solution.replace(/\;/gi,",");
    try {
      // regexp umsetzung von Intervallausdruck in die beiden Grenzen muss noch erledigt werden
      // sowie check in check_group und der init
      ob.solcodea = mathJS.compile("0");
      ob.solcodeb = mathJS.compile("0");
    } catch(e) {
      log.warn( "Solution of type " + type + " not compileable: " + solution);
      ob.solcodea = mathJS.compile("0");
      ob.solcodeb = mathJS.compile("0");
    }

  } else {
    ob.solution = solution;
    try {
      if ((type != 1) && (type != 3) && (type != 6) && (type != 7)) {
          var rt = mparser.convertMathInput(solution);
          ob.solcode = mathJS.compile(rt.mathjs);
    } else {
        ob.solcode = mathJS.compile("0");
        // workaround fuer mehrelementige oder Intervallartige Loesungen bei MParsedQuestion oder MSpecialQuestion sowie Textloesungen fuer MQuestion
    }
      log.trace("Successfully compiled " + solution);
    } catch(e) {
    log.warn( "Solution of type " + type + " not compileable: " + solution + ", exception = " + JSON.stringify(e));
    ob.solcode = mathJS.compile("0");
    }
  }
  ob.valcode = mathJS.compile("0");
  ob.valvalid = false;
  ob.type = type;
  ob.option = option;
  ob.maxpoints = pnts;
  ob.points = 0; // wird nur von notifyPoints gefuellt !
  ob.message = "";
  ob.element = null;
  ob.intest = (intest>=1);
  ob.section = section;
  ob.uxid = uxid;
  ob.value = 0; // nur von typ 2 genutzt

  // Elemente werden von handlerChange nach Eingabe des Benutzers gefuellt
  ob.rawinput = "";
  ob.texinput = "";
  ob.parsedinput = "";

  // Dynamische prepare-Funktion unabhaengig vom Fragefeldtyp einbauen
  // Funktion bekommt das dem Feld zugewiesene DOM-Element als Parameter, clear xoder externes setting wird danach separat ausgefuehrt in InitResults
  ob.prepare = function() {
	  this.element = document.getElementById(this.id);
	  if (this.type == 2) {
		  this.image = document.getElementById(this.option);
	  }
  };

  /**
   * Display a visual cue during exercise input
   * (e.g. question mark, cross, check).
   *
   * @param status - one of SOLUTION_NEUTRAL (default), SOLUTION_TRUE or SOLUTION_FALSE
   */
  ob.displayFeedback = function( status ) {
	switch( status ) {
		case SOLUTION_NEUTRAL:
			className = "glyphicon-question-sign";
			color = QCOLOR_NEUTRAL;
			break;
		case SOLUTION_TRUE:
			className = "glyphicon-ok";
			color = QCOLOR_TRUE;
			break;
		case SOLUTION_FALSE:
			className = "glyphicon-remove";
			color = QCOLOR_FALSE;
			break;
		default:
			className = "glyphicon-question-sign";
			color = QCOLOR_NEUTRAL;
	}

	// Get the image element on the page and set the bootstrap class
	var icon = document.getElementById( this.imgid );
	if ( typeof icon != 'undefined' && icon !== null ) {
		icon.className = "glyphicon " + className;
		icon.style.color = color;

	} else {
		log.warn( "Can't display status for image " + this.imgid );
	}
	// get the input field and change the background color
	if ( this.type != 2 ) {
		var field = document.getElementById( this.id );
		if ( typeof field != 'undefined' && field !== null ) {
			log.debug("color " + color);
			field.style.backgroundColor = color;
		}
	}
  }

  // Dynamische clear-Funktion abhaengig vom Fragefeldtyp einbauen
  if ((type == 1) | (type == 3) | (type == 4) | (type == 5) | (type == 6) | (type == 7)) {
      ob.rawloadvalue = function(val) { // Nur Benutzung in clear
            document.getElementById(this.id).value = val; // Stringbasierte Felder
            this.rawinput = val;
            check_group(this.counter,this.counter);
      };
      ob.clear = function() {
            this.texinput = "\\text{(Keine Eingabe)}";
            this.parsedinput = "0";
            this.valcode = mathJS.compile("0");
            this.valvalid = false;
            this.rawloadvalue("");
      };
  } else
  {
    if (type == 2) {
      // Uebersetzen der values fuer die Loesung: tex: 0 und 1, js: 0 = noch nicht geclickt, 1 = angewaehlt, 2 = abgewaehlt
      if (ob.solution == "0") ob.solution = "2"; else ob.solution = "1";
      ob.clear = function() {
        this.element.checked = false;
        this.element[ getIndeterminatePropName() ] = true;
        this.value = "0";
        this.element.cval = "0"; this.message = ""; this.displayFeedback(); notifyPoints(this.counter, 0, SOLUTION_NEUTRAL); };
      ob.rawloadvalue = function(val) {
          this.value = val;
          this.element.cval = val;
          this.message = "";
          this.displayFeedback(); // this.image.src = imagesPath + "questionmark.png";
          if ((val == "0") || (val == "")) {
              // nothing selected yet
              this.element.checked = false;
              this.element[getIndeterminatePropName()] = true;
          }
          if (v == "1") {
              // yes selected
              this.element.checked = true;
              this.element[getIndeterminatePropName()] = false;
          }
          if (v == "2") {
              // no selected
              this.element.checked = false;
              this.element[getIndeterminatePropName()] = false;
          }
      }
    } else {
      // UNBEKANNTER TYP
    }
  }

  var integrationsSchritte = 100;
  // convert-Funktion je nach Typ setzen
  if ((type == 1) | (type == 3) | (type == 4) | (type == 5) | (type == 7)) {
    // Feldtypen rendern und parsen ihre Eingabe ganz normal
    ob.convertinput = function() { return mparser.convertMathInput(notationParser_IN(this.rawinput), integrationsSchritte ); }
  } else {
    if (type == 6) {
      // Bei Intervallfragefeldern das Parsing auf die Intervallgrenzen anwenden
      ob.convertinput = function() { return mparser.convertMathInput(notationParser_IN(this.rawinput), integrationsSchritte ); }
    }
  }

  FVAR.push(ob);

}


// Blendet Einstellungsseite ein und aus
function toggle_settings() {
  var e = document.getElementById("settings");
  if (e != null) {
    if (e.style.visibility == "hidden") {
      e.style.top = "15%";
      e.style.left = "15%";
      e.style.width = "70%";
      e.style.height = "70%";
      e.style.visibility = "visible";
      MathJax.Hub.Queue(["Typeset", MathJax.Hub, e]);
    } else {
      e.style.top = "0";
      e.style.left = "0";
      e.style.width = "0";
      e.style.height = "0";
      e.style.visibility = "hidden";
    }
  }
}

function selectColor(c) {
  log.debug("Color select: " + c);
  if (intersite.isActive() == true) {
    if (intersite.getObj() != null) {
      intersite.getObj().configuration.stylecolor = c;
    }
  }
  applyLayout(false);
}

// Blendet Hinweis-Bereiche ein und aus
function toggle_hint(div_id) {
    var e = document.getElementById(div_id);
    if (e != null) {
      if (e.style.display == 'none') {
        e.style.display = 'block';
      } else {
        e.style.display = 'none';
      }
    }
    e = document.getElementById(div_id + "_button");
    if (e != null) {
      if (e.className == "hintbutton_closed") {
        e.className = "hintbutton_open";
      } else {
        if (e.className == "hintbutton_open") {
          e.className = "hintbutton_closed";
        } else {
          if (e.className == "chintbutton_closed") {
            e.className = "chintbutton_open";
          } else {
            if (e.className == "chintbutton_open") {
              e.className = "chintbutton_closed";
            }
      }
    }
      }
    }
}

// Ueberprueft, ob eine Benutzereingabe einem Vereinfachungsmuster entspricht, Typen wie in mintmod.tex bei MSimplifyQuestion
// 0 = Keine Vereinfachung gefordert, nur normale Syntaxchecks werden gemacht
// 1 = Keine Klammern (runde oder eckige) mehr im vereinfachten Ausdruck
// 2 = Faktordarstellung (Term hat Produkte als letzte Operation, Summen als vorgeschaltete Operation)
// 3 = Summendarstellung (Term hat Summen als letzte Operation, Produkte als vorgeschaltete Operation)
// Werte 0...15 sind Typen, Flags 16,32,64,128,256,512 sind optional
// 16 = Nur ein slash (Bruchstrich) im Ausdruck gestattet
// 32 = Stammfunktion gefragt, input wird nur modulo Konstanten bewertet (indem die zu f(0)=0 normiert wird)
// 64 = Keine Wurzelfunktion erlaubt (muss als x^(1/2) geschrieben werden)
// 128 = Keine Betragsfunktion erlaubt (muss als Fallunterscheidung geschrieben werden)
// 256 = Keine Brueche und keine Potenzen erlaubt (also kein / und kein ^ mit dem man ein ^(-1) schummeln koennte)
// 512 = Besondere Stuetzstellen (nur >1 und nur schwach rational, sonst symmetrisch um Nullpunkt und ganze Zahlen)
// 1024 = Nur String aus Ziffern 0,..,9 in Loesung erlaubt
// 2048 = Nur hoechstens ein ^ und kein / und * erlaubt
// Rueckgabe: Array aus string-int-Paaren, jeweils Meldung und ob die Loesung gemaess den Vereinfachungsregeln erlaubt ist (0) oder nicht (1)
function checkSimplification(type, input) {
  var ret = new Array();

  // Allgemeine Pruefungen

  if (input.indexOf("|") != -1) {
      ret.push(new Array("abs(...) statt |...|" , 1));
  }

  if (input.indexOf("e^") != -1) {
      ret.push(new Array("exp(TERM) statt e^TERM" , 1));
  }

  if (input.indexOf("\\") != -1) {
      ret.push(new Array("Backslash-Notation verwendet" , 0));
  }

  if (input.indexOf(")(") != -1) {
      ret.push(new Array("(...)*(...) statt (...)(...)" , 1));
  }

  var rx = /(\d+)([a-zA-Z(]+)/;
  var res = rx.exec(input);
  if (res != null) {
    if (res.length >= 3) {
        ret.push(new Array("Produkte in Form " + res[1] + "*" + res[2] + " statt " + res[1] + res[2], 1));
    }
  }


  if ((type & 15) == 1) {
    // Alle Klammern durch runde Klammern ersetzen
    var rex = new RegExp('\\[','gi');
    input = input.replace(rex,"(");
    rex = new RegExp('\\]','gi');
    input = input.replace(rex,")");
    if ((input.indexOf("(") != -1) || (input.indexOf(")") != -1)) {
      ret.push(new Array("L&#246;sung ist nicht vereinfacht" , 1));
    }
  }

  if ((type & 15) == 3) {
    // Hoechste Operation muss Addition/Subtraktion sein, Addition/Subtraktion darf auf tieferen Ebenen nicht vorkommen
    // Alle Klammern durch runde Klammern ersetzen
    var rex = new RegExp('\\[','gi');
    input = input.replace(rex,"(");
    rex = new RegExp('\\]','gi');
    input = input.replace(rex,")");
  }


  if ((type & 16) == 16) {
    // Nur ein Bruchstrich erlaubt
    if (input.indexOf("/") != -1) {
      if (input.indexOf("/") != input.lastIndexOf("/")) {
    ret.push(new Array("Bruch ist nicht zusammengefasst" , 1));
      }
    }
  }

  if ((type & 64) == 64) {
    // Keine Wurzelfunktion erlaubt
    if (input.indexOf("sqrt") != -1) {
      ret.push(new Array("Wurzeln sollen als Exponenten geschrieben werden" , 1));
    }
  }

  if ((type & 128) == 128) {
    // Keine Betragsfunktion erlaubt
    if ((input.indexOf("abs") != -1) | (input.indexOf("|") != -1)) {
      ret.push(new Array("Betragsstriche sollen durch eine Fallunterscheidung geschrieben werden" , 1));
    }
  }

  if ((type & 256) == 256) {
    // Keine Brueche und keine Potenzen erlaubt
    if ((input.indexOf("^") != -1) | (input.indexOf("/") != -1)) {
      ret.push(new Array("L&#246;sung darf keine Nenner oder Potenzen enthalten" , 1));
    }
  }

  if ((type & 1024) == 1024) {
    // Nur natuerliche Zahl in Rohform erlaubt
    var t = input.trim();
    if (isProperNumber(t) == false) {
      ret.push(new Array("L&#246;sung soll eine Zahl sein" , 1));
    }
  }

  if ((type & 2048) == 2048) {
    // Nur hoechstens ein ^ und kein / und * erlaubt
    if (input.indexOf("^") != -1) {
      if (input.indexOf("^") != input.lastIndexOf("^")) {
        ret.push(new Array("Potenzen sollen zusammengefasst werden" , 1));
      }
    } else {
      if ((input.indexOf("/") != -1) || (input.indexOf("*") != -1)) {
        ret.push(new Array("Nenner und Faktoren sollen aufgel&#246;st werden" , 1));
      }
    }

  }


  return ret;
}

function isProperNumber(s) {
  if (s.indexOf("x") != -1) return false; // schliesst Hexadezimalzahlen aus
  if (s.indexOf("b") != -1) return false; // schliesst Binaerzahlen aus
  if (s.indexOf("o") != -1) return false; // schliesst Oktalzahlen aus

  return $.isNumeric(s);
}

// Wird von einem input-Element aufgerufen, wenn der Fokus erhalten geht, passiert auch wenn Gruppe aktiv ist, da diese nur content-Checking betrifft
function handlerFocus(id) {
    if (FVAR[id].id != activefieldid) handlerChange(id,1);
}

// Wird von einem input-Element aufgerufen, wenn der Fokus verloren geht, passiert auch wenn Gruppe aktiv ist, da diese nur content-Checking betrifft
function handlerBlur(id) {
    if (FVAR[id].id == activefieldid) closeInputContent();
}

// Wird aufgerufen, wenn ein change-Event eines Eingabefelds eingetreten ist
// id = Index in Felderarray
// nocontentcheck == 1 -> Feld soll jetzt nicht kontrolliert werden (Feld gehoert z.B. zu Aufgabengruppe)
function handlerChange(id, nocontentcheck) {
  log.debug("mintscripts_bootstrap: handlerChange");
  // override: checkboxen mit ausschliessenden Boxen werden immer dargestellt
  if (FVAR[id].type == 2) {
    if (FVAR[id].smc.length > 0) nocontentcheck = 0;
  }

  var formula = 0; // Stellt der Feldinhalt eine Formel dar?
  if (FVAR[id].type == 4) formula = 1; // Eingabefeld fuer mathematische Ausdruecke? Rohe Zahlen oder Intervalle werden nicht gehintet
  if (formula == 1) {
	log.debug("mintscripts_bootstrap: formula == 1");
    var e = document.getElementById(FVAR[id].id);
    FVAR[id].rawinput = e.value;
    FVAR[id].texinput = "";
	log.debug("mintscripts_bootstrap: rawinput " + e.value);
    if (e.value != "") {
      try {
	    // Eingabe konnte geparset werden
	    var ob = FVAR[id].convertinput();
	    FVAR[id].texinput = notationParser_OUT(ob.latex);
	    FVAR[id].parsedinput = ob.mathjs;
	    FVAR[id].valcode = mathJS.compile(ob.mathjs);
	    FVAR[id].valvalid = true;

      } catch(e) {
	    // Eingabe konnte nicht geparset werden
	    if (FVAR[id].texinput == "") FVAR[id].texinput = "\\text{("+$.i18n("msg-incorrect-input")+")}"; // "Fehlerhafte Eingabe"
	    FVAR[id].parsedinput = "0";
	    FVAR[id].valcode = mathJS.compile("0");
	    FVAR[id].valvalid = false;
      }
      log.debug("mintscripts_bootstrap: valid input " + FVAR[id].valvalid);

    } else {
      // Eingabe war leer
      FVAR[id].texinput = "\\text{("+$.i18n("msg-missing-input")+")}"; // "Keine Eingabe"
      FVAR[id].parsedinput = "0";
      FVAR[id].valcode = mathJS.compile("0");
      FVAR[id].valvalid = false;
    }
  }

  if (nocontentcheck != 1) {
      check_group(id, id); // Erzeugt ggf. Meldungen, die zusaetzlich zur Formel angezeigt werden

      if (FVAR[id].points == FVAR[id].maxpoints) {
        if ((intersite.isActive() == true) && (FVAR[id].sync == 1)) {
            if (intersite.getObj().configuration.CF_TESTS == "1") {
            var st = "";
            var timestamp = +new Date();
            st = "EXSUCCESS: " + "CID:" + signature_CID + ", user:" + intersite.getObj().login.username + ", timestamp:" + timestamp + ", pagename:" + fullName + ", uxid:" + FVAR[id].uxid + ", elementid:" + id + ", input:" + FVAR[id].rawinput + ", message:" + FVAR[id].message;
            intersite.sendeFeedback( { statistics: st }, true);
            }
        }
      }
  }

  if (formula == 1) {
    var s = FVAR[id].texinput;
    log.debug("mintscripts_bootstrap: textinput " + s );
    displayInputContent(id,s);
    var u = document.getElementById("UFIDM" + activefieldid);
    log.debug("mintscripts_bootstrap: u " + u);
    if (u != null) {
      u.innerHTML = FVAR[id].message;
      u.style.background = e.style.background;
    } else {
      log.trace("UFIDM not available"); // passiert z.B. bei geschlossenen Tests staendig da Messagepart dann nicht angezeigt ist
    }
  } else closeInputContent();


}

// Callback fuer die Fragegruppen-Buttons
function group_button(input_from, input_to) {
  check_group(input_from, input_to);
}


function check_all() {
  // FVAR[0] ist dummy
  if (FVAR.length > 1) check_group(1,FVAR.length-1);
}

// Hilfsfunktion, die convertMathInput fuer den Fall kapselt, dass nur eine einfache Uebersetzung und keine Fehlerverarbeitung
// und keine LaTeX-Darstellung noetig ist (als Ersatz fuer pureParse aus parser.js).
// Der Ausdruck muss zu einer festen Zahl auswertbar sein (Konstrukte erlauben?)
// Eingabe: Eingabestring des Benutzers, Ausgabe: double (fester Zahlenwert)
// Bei Fehlern und Exceptions wird NaN geliefert
function rawParse(eingabe) {
   try {
     var retobj = mparser.convertMathInput(eingabe,2);
     var mjs = retobj.mathjs;
         var z = mparser.evalMathJS(mjs);
     return z;
   } catch(e) {
     return NaN;
   }
}

// Uebernimmt die Inhalte der DOM-Elemente von Question-Feldern und faerbt sie entsprechend ein (auch Checkboxen!)
function check_group(input_from, input_to) {
    log.debug('mintscripts_bootstrap: check_group called', input_from, input_to);
    var d = document;
    var i;
    var s;


    if (isTest == true) {
      // Bei Tests bilden alle vorhandenen Fragefelder eine Gruppe
      nPoints = 0;
      nMaxPoints = 0;
    }

    for (i=input_from; i<=input_to; i++) {
            s = FVAR[i].id;
            var e = d.getElementById(s);

            // element may not exist, for example if it is part of roulette exercise which is not active
            if (e != null) {

            switch(FVAR[i].type) {

              case 1: {
                // Eingabefeld mit alphanumerischer Loesung, case-sensitive
                var v = e.value;
               var sol = FVAR[i].solution;
               FVAR[i].rawinput = v;
               if (v == sol) {
                  FVAR[i].message = "";
                  notifyPoints(i, FVAR[i].maxpoints, SOLUTION_TRUE);
                } else {
                  if (v == "") {
                    FVAR[i].message = "";
                    notifyPoints(i, 0, SOLUTION_NEUTRAL);
                 } else {
                    FVAR[i].message = $.i18n("msg-incorrect-answer"); // Lösung inkorrekt
                    notifyPoints(i, 0, SOLUTION_FALSE);
                  }
                }
                break;
              }

              case 2: {
                // tristate checkbox: indeterminate, true determinate, false determinate (having intersite values "0", "1", "2"), stored in val attribute of the element
                var v = e.cval;

                if (v == "") {
                    log.trace("cval \"\" mapped to \"0\"");
                    v = "0";
                }

                if (v == "1") {
                    // dirty: Eigentlich sollte der neue Wert auch durch checkgroup getestet werden, aber das fuehrt auf eine Rekursion...
                    var j;
                    for (j = 0; j < FVAR[i].smc.length; j++) {
                        log.trace("smc exclude = " + FVAR[i].smc[j]);
                        var k;
                        for (k = 0; k < FVAR.length; k++) {
                          if (FVAR[k].uxid == FVAR[i].smc[j]) {
                              FVAR[k].value = "2";
                              FVAR[k].rawinput = "2";
                              var f = d.getElementById(FVAR[k].id);
                              if (f != null) {
                                  f.checked = false;
                                  f.prop( getIndeterminatePropName(), false);
                                  f.setAttribute("data-val", "2")
                              }
                              notifyPoints(k, 1, SOLUTION_TRUE); // sollte das nicht false sein? Aber ist nur Bild..
                          }
                        }
                    }
                }

                FVAR[i].value = v;
                FVAR[i].rawinput = v;
                if (v == "0") {
                    notifyPoints(i, 0, SOLUTION_NEUTRAL);
                } else {
                    if (v == FVAR[i].solution) {
                        notifyPoints(i, FVAR[i].maxpoints, SOLUTION_TRUE);
                    } else {
                        notifyPoints(i, 0, SOLUTION_FALSE);
                    }
                }

              break;
              }

              case 3: {
                // Eingabefeld mit reeller Loesung, geparset, exakt bis auf OPTION Stellen hinter dem Komma
                // Leerstring in Vorgabeloesung: Leere Menge ist gefragt (nicht leerer String)
                // Mehrere durch Kommata getrennte Werte in Loesung: Endliche Menge ist als Eingabe gefragt
                // Mehrere durch Semikolon getrennte Werte in Loesung: Endliche Menge ist als Eingabe gefragt [ Nur eingegebene Werte, die Vorgabeloesung ist immer mit Kommata zu schreiben ]

                FVAR[i].rawinput = e.value;
                var stellen = FVAR[i].option;
                var soluta = FVAR[i].solution.split(","); // hat nie Mengenklammern

                // Mehr als eine Musterloesung (die gleich sein koennen): Mengenklammern werden in Eingabe verlangt, auch wenn es nur eine Loesung ist
                // Nur eine Musterloesung: Keine Mengenklammern in Loesungseingabe erlaubt

                var valuta = {};
                var ok = 1;
                var solleer = 0; // leere Menge gefragt (wird sonst nicht erkannt weil split ein Element (Leerstring) liefert
                if (FVAR[i].solution == "") {
                    solleer = 1;
                    soluta = {}; // die leere Menge als leeres Array moeglicher Werte
                }

                if ((soluta.length == 1) && (solleer == 0)) {
                     // Es ist ein Element ohne Angabe von Mengenklammern gefragt
                     valuta = notationParser_IN(e.value).split(",");
                     if (valuta.length != 1) {
                         ok = 0;
                     } else {
                        if ((valuta[0].indexOf("{") != -1) | (valuta[0].indexOf("}") != -1)) ok = 0;
                     }
                } else {
                     // Es ist eine Menge (ggf. leer oder einelementig) gefragt
                     var tr = notationParser_IN(e.value).trim();
                     if ((tr.indexOf("{") != 0) | (tr.indexOf("}") != (tr.length-1))) {
                         // Mengenklammern nicht richtig gesetzt oder nicht vorhanden
                         ok = 0;
                     } else {
                         var st = tr.substr(1,tr.length-2);
                         if (st.trim() == "") {
                             valuta = {};
                             log.trace("Benutzer hat leere Menge eingegeben");
                         } else {
                           valuta = st.split(",");
               if (valuta.length==1) {
                 // Alternativ Semikolon moeglich, aber nur wenn kein Komma gefunden
                 valuta = st.split(";");
              }
                        }
                     }
                }

                // Pruefe beide Teilmengenrelationen, d.h. doppelte Auffuehrungen von Elementen gelten als richtig
                for (vj=0; ((vj<valuta.length) & (ok==1)); vj++) {
                   var c = 0;
                   var v = rawParse(valuta[vj]);
                   for (sj=0; ((sj<soluta.length) & (c==0)); sj++) {
                      var s = rawParse(soluta[sj]);
                      if (Math.abs(extround(v,stellen)-extround(s,stellen)) <= Math.pow(10,(stellen+2)*(-1))) c = 1;
                   }
                   if (c==0) ok = 0;
                }
                for (sj=0; ((sj<soluta.length) & (ok==1)); sj++) {
                   var c = 0;
                   var s = rawParse(soluta[sj]);
                   for (vj=0; ((vj<valuta.length) & (c==0)); vj++) {
                      var v = rawParse(valuta[vj]);
                      if (Math.abs(extround(v,stellen)-extround(s,stellen)) <= Math.pow(10,(stellen+2)*(-1))) c = 1;
                   }
                   if (c==0) ok = 0;
                }


        if (ok == 1) {
                  FVAR[i].message = "";
                  notifyPoints(i, FVAR[i].maxpoints, SOLUTION_TRUE);
                } else {
                  if (e.value == "") {
                    FVAR[i].message = "";
                    notifyPoints(i, 0, SOLUTION_NEUTRAL);
                  } else {
                    if ((soluta.length == 1) && (solleer == 0)) {
                        FVAR[i].message = $.i18n("msg-incorrect-value"); // "Wert inkorrekt"
                    } else {
                        FVAR[i].message = $.i18n("msg-incorrect-quantity"); // "Lösungsmenge inkorrekt"
                    }
                    notifyPoints(i, 0, SOLUTION_FALSE);
                  }
                }
                break;
              }

              case 4: {
                // Eingabefeld mit Funktionsausdruck als Loesung, geparset, approximierter Vergleich an den Stuetzstellen 1,2,...,Anzahl verschoben um Anzahl/2 nach links
        // Ggf. Vereinfachungsvorschrift (Fall 5)

            var options = FVAR[i].option.split(";",4);
                var stuetzen = options[0];
                var varia = options[1].split(","); // Mehrere Auswertungsvariablen durch Komma getrennt erkennen
        var stellen = options[2];
                var vereinfachung = options[3]; // Werte 0..15 sind Vereinfachungstyp (0 = keine), Flags 16,32,64,128 sind optional

                var k;
                var message = "";
                var ok = true;

                // FVAR[i].rawinput und andere muessen hier vor Aufruf (z.B. von handlerChange) gesetzt sein (was gefixt werden muss)

        if (FVAR[i].valvalid == false) {
          ok = false;
          message = $.i18n("msg-unanswered-question"); // "Frage noch nicht beantwortet"
          log.debug('mintscripts_bootstrap: message set to', message);
        } else {

        var c1,c2;

        if ((vereinfachung & 32) == 32) {
          // Nur nach Stammfunktion gefragt, beide Funktionen werden auf f(1.234)=0 normiert, es wird davon ausgegangen, dass es nur eine Variable gibt
          // und dass die Funktion bei x=1.234 existiert.
          var scope = mathJSFunctions;
          scope[varia[0]] = 1.234;
          c1 = FVAR[i].valcode.eval(scope);
          c2 = FVAR[i].solcode.eval(scope);
        }


                var first;
            if ((vereinfachung & 512) == 512) {
          // Besondere (nur positive und nur schwach rationale) Stuetzstellen gefordert
                  first = 1.1957856840; // sollte nicht aus versehen als Bruch irgendwo auftreten
        } else {
          // Normale Stuetzstellen (positive und negative, fast symmetrisch, und Null wird getroffen wenn mehr als eine Stelle verlangt)
                  first = 1 - (stuetzen*0.5); // erste Stuetzstelle, Definition macht JavaScript auch klar dass es floats sind
        }


        vv = [];
        for (vj=0; vj<varia.length; vj++) vv[vj] = first;

                try {

          // ---------- Starting eval for vv = " + vv + " --------------------");

          var ok = true;
          var fini = false;

          while (fini == false) {
            // Bei gegebenen Stuetzstellen in vv auswerten
            var scope = mathJSFunctions;
            for (vj=0; vj<varia.length; vj++) {
              scope[varia[vj]] = vv[vj];
            }
                    s = FVAR[i].solcode.eval(scope);
            v = FVAR[i].valcode.eval(scope);
                    if ((vereinfachung & 32) == 32) {
                        s = s - c2;
                        v = v - c1;
                    }

            var pd = "norm(" + s + " - " + v + ")";
                    var ed = rawParse(pd);

            if (!(Math.abs(extround(ed,stellen)-extround(0,stellen)) <= Math.pow(10,(stellen+2)*(-1)))) {
              ok = false;
              fini = true;
              message = $.i18n("msg-still-incorrect-input"); // "Eingabe ist noch nicht richtig"
            }

            // Gesamtes Stuetzstellenarray inkrementieren
            var index = 0;
            var inc = true;
            while (inc == true) {
              (vv[index])++;
              if (vv[index] > stuetzen) {
            vv[index] = first;
            index++;
            if (index == varia.length) {
              // Ganzes array durchinkrementiert
              inc = false;
              fini = true;
            }
              } else {
            inc = false;
              }

            }


          }

                  if (ok == true) message = $.i18n("msg-correct-answer"); // "Dies ist eine richtige L&#246;sung"


        } catch(e) {
          ok = false;
          message = $.i18n("msg-malformed-input"); // "Form der Eingabe ist fehlerhaft"
        }

                var messages = checkSimplification(vereinfachung, FVAR[i].rawinput);


        for (k=0; k<messages.length; k++) {
                    // if (message != "") { message = message + "<br />"; }
                    message = message + "<div style='color:#454545'>" + messages[k][0] + "</div>";
                    if (messages[k][1] == 1) ok = false;
                }

        } // endif von valvalid-test


                FVAR[i].message = message;
        if (ok) {
                  notifyPoints(i, FVAR[i].maxpoints, SOLUTION_TRUE);
                } else {
                  if (e.value == "") {
                    notifyPoints(i, 0, SOLUTION_NEUTRAL);
                  } else {
                    notifyPoints(i, 0, SOLUTION_FALSE);
                  }
                }


        break;
              }


         case 6: {
                             FVAR[i].rawinput = e.value;
        var b = notationParser_IN(e.value.trim());
                b = b.replace(/;/gi,","); // Kommata und Semikolon in Musterloesung und Eingabe zulassen (Semikolon in Musterloesung wird von CreateQuestionObj verarztet)
                var stellen = FVAR[i].option;

        var typl = 0; // 0 = nicht bekannt, 1 = offen, 2 = abgeschlossen
        var typr = 0;
        var btypl = 0;
        var btypr = 0;
        var leftok = true;
        var rightok = true;

            ok = 0;
        var matchSol = FVAR[i].solution.match(/([([\]]{1})([^()[\],]*),([^()[\],]*)([)[\]]{1})/);

        if (!matchSol)
          {log.warn( "Loesungsintervall " + FVAR[i].solution + " ist fehlerhaft");}

         else {

                  // Alternativen fuer "infty" erkennen
                  b = b.replace(/infinity/g, 'infty');
                  b = b.replace(/unendlich/g, 'infty');
                  var matchUser = b.match(/([([\]]{1})([^()[\],]*),([^()[\],]*)([)[\]]{1})/);

                  if (matchUser)
                    {
                      if ((matchSol[1]=="(" )|| (matchSol[1]=="]")) typl = 1;
                      if (matchSol[1]=="[") typl = 2;

                      if ((matchUser[1]=="(") || (matchUser[1]=="]")) btypl = 1;
                      if (matchUser[1]=="[") btypl = 2;

                      if ((matchSol[4]==")") || (matchSol[4]=="[")) typr = 1;
                      if (matchSol[4]=="]") typr = 2;

                      if ((matchUser[4]==")") || (matchUser[4]=="[")) btypr = 1;
                      if (matchUser[4]=="]") btypr = 2;

                      if ((typl == btypl) && (typr == btypr)) {
                          //console.log ("Check solution");
                          //console.log (matchSol[2].toString()+ " --- " + matchUser[2].toString());
                          //console.log (matchSol[3].toString()+ " --- " + matchUser[3].toString());

                          if (matchSol[2].trim() != matchUser[2].trim())
                          { var left_user = rawParse(matchUser[2])
                            if ((isNaN(left_user)) || (Math.abs(extround(left_user,stellen)-extround(rawParse(matchSol[2]),stellen)) > Math.pow(10,(stellen+2)*(-1))))
                                leftok = false;
                           }

                           if (matchSol[3].trim() != matchUser[3].trim())
                          { var right_user = rawParse(matchUser[3])
                            if ((isNaN(right_user)) || (Math.abs(extround(right_user,stellen)-extround(rawParse(matchSol[3]),stellen)) > Math.pow(10,(stellen+2)*(-1))))
                                rightok = false;
                           }

                        ok = rightok && leftok;
                        }


           }
        }



                if (ok == 1) {
          FVAR[i].message = "Dies ist eine richtige L&#246;sung";
                  notifyPoints(i, FVAR[i].maxpoints, SOLUTION_TRUE);
                } else {
                  if (e.value == "") {
            FVAR[i].message = "";
                    notifyPoints(i, 0, SOLUTION_NEUTRAL);
                  } else {
            FVAR[i].message = $.i18n("msg-incorrect-interval"); // "Ist nicht das gesuchte Intervall"
                    notifyPoints(i, 0, SOLUTION_FALSE);
                  }
                }


        break;
              }

         case 7: {
            // Spezialisiertes Eingabefeld, Wirkung haengt von Fallindex ab
                FVAR[i].rawinput = e.value;
        var b = notationParser_IN(e.value.trim());
                var ok = 0;


            var options = FVAR[i].option.split(";",4);
                var stuetzen = options[0];
                var varia = options[1].split(","); // Mehrere Auswertungsvariablen durch Komma getrennt erkennen
        var stellen = options[2];
                var styp = options[3]; // string der Spezialtyp der Aufgabe angibt


                var message = "";

        switch(styp) {

          case "onlyempty": {
                    if (b.trim().length == 0) ok = 1;
            break;
          }

                  case "vector": {
                    var n = rawParse(b);
                    ok = 1;
                    break;
                  }

          case "evennat": {
            var n = rawParse(b);
            if ((n >= 1) && (Math.floor(n) == n) && (n % 2 == 0)) ok = 1;
            break;
          }

          case "oddnat": {
            var n = rawParse(b);
            if ((n >= 1) && (Math.floor(n) == n) && (n % 2 == 1)) ok = 1;
            break;
          }

          case "intervalelement": {
                    // Kommata und Semikolon in Musterloesung zugelassen (Semikolon in Musterloesung wird von CreateQuestionObj verarztet)
                    var typl = 0, typr = 0;
            var s = FVAR[i].solution;
            if (s.indexOf("(") != -1) typl = 1;
            if (s.indexOf("[") != -1) typl = 2;
            if (s.indexOf("(-infty") != -1) typl = 3;
            if (s.indexOf("(infty") != -1) typl = 0;
            if (s.indexOf(")") != -1) typr = 1;
            if (s.indexOf("]") != -1) typr = 2;
            if (s.indexOf("infty)") != -1) typr = 3;
            if (s.indexOf("-infty)") != -1) typr = 0;

            if ((typr == 0) || (typl == 0)) {
              log.warn( "Loesungsintervall " + FVAR[i].solution + " ist fehlerhaft (Aufgabe Typ 7)");
            } else {

                  var t = s.split(",");
              if (t.length == 2) {
            ok = 1;
            var l = rawParse(b);
            if (b.trim() == "") {
              // Leerstring ist keine richtige Eingabe und fuehrt bei echtem Leerstring zu grauem Feld
              l = NaN;
              ok = 0;
            }
                t[0] = t[0].substring(1,t[0].length).trim();
                t[1] = t[1].substring(0,t[1].length-1).trim();
                    var h0 = rawParse(t[0]);
                    var h1 = rawParse(t[1]);
                        var sl = l + " "; // Umgehung eines Fehlers wenn l nur Zahl und nicht String ist
                if ((sl.indexOf(",") != -1) | (sl.indexOf("[") != -1) | (sl.indexOf("]") != -1)) {
                          ok = 0; // Vektor oder Intervall vom Benutzer eingegeben, aber Zahl erwartet. Muss separat abgefangen werden da JavaScript sonst Strings vergleicht
                        } else {
                          if ((typl == 1) && (h0 >= l)) ok = 0;
                          if ((typl == 2) && (h0 > l)) ok = 0;
                          if ((typr == 1) && (h1 <= l)) ok = 0;
                          if ((typr == 2) && (h1 < l)) ok = 0;
                       }
              }
            }

            break;
          }

                  case "exactfraction": {
                    // Bruch muss zur Loesung aequivalent sein, sowie maximal gekuerzt und mit positivem Nenner

                    var options = FVAR[i].option.split(";",4);
                    var stellen = options[0];
                    var s = FVAR[i].solution;
                    var sp = -1.2;
                    var l = 0;
                    if (b.trim() == "") {
                      // Leerstring ist keine richtige Eingabe und fuehrt bei echtem Leerstring zu grauem Feld
                      l = NaN;
                      ok = 0;
                    } else {
                      l = rawParse(b);
                      sp = rawParse(s);
                      ok = 1;
                    }

                    // Richtiger Bruchwert bis auf Abschaetzung?
                    if (Math.abs(extround(l,stellen)-extround(sp,stellen)) <= Math.pow(10,(stellen+2)*(-1))) {
                    } else {
                        ok = 0;
                    }

                    // Bruch maximal gekuerzt, nur Zahlen benutzt und Nenner positiv?
                    if (b.indexOf("/") == -1) {
                        // ist es eine ganze Zahl?
                        var rx = /(-?\d+)/ ;
                        var m;
                        if ((m = rx.exec(b)) != null) {
                            if (m[1] != b) {
                                ok = 0; // ist keine reine ganze Zahl
                            }
                        } else {
                            ok = 0; // ist keine reine ganze Zahl
                        }

                    } else {
                        var fr = b.split("/");
                        if (fr.length != 2) {
                            ok = 0;
                        } else {
                            fr[0] = fr[0].trim();
                            fr[1] = fr[1].trim();

                            var rex = /(-?\d+)/ ;
                            var u;
                            // Test dass nur ganze Zahlen benutzt wurden und Nenner positiv ist
                            if ((u = rex.exec(fr[0])) != null) {
                                if (u[1] == fr[0]) {
                                  if ((u = rex.exec(fr[1])) != null) {
                                    if (u[1] == fr[1]) {
                                        var a = rawParse(fr[0]);
                                        if (a < 0) { a = -a; }
                                        var b = rawParse(fr[1]);
                                        var g = mygcd(a,b);
                                        if ((g != 1) || (b <= 0)) ok = 0;
                                    } else {
                                      ok = 0;
                                    }
                                  } else {
                                    ok = 0;
                                  }
                                } else {
                                    ok = 0;
                                }
                            } else {
                              ok = 0;
                            }
                        }
                    }


                    break;
                  }


              case "inputstring2": {
                // Zur Datenerfassung: Strings mit genau 2 Zeichen (ohne trim) werden akzeptiert
                if (b.length == 2) ok = 1;
                break;
              }

              case "inputnumber2": {
                // Zur Datenerfassung: Strings mit genau 2 ZIFFERN (ohne trim) werden akzeptiert
                if (b.length == 2) {
                    if (isNaN(parseInt(b)) == false) {
                      ok = 1;
                    }
                }
                break;
              }

                  default: {
            log.warn( "STYP " + styp + " nicht bekannt (MSpecialQuestion)");
            ok = 0;
            break;
          }
        }

                if (ok == 1) {
          FVAR[i].message = "Dies ist eine richtige L&#246;sung";
                  notifyPoints(i, FVAR[i].maxpoints, SOLUTION_TRUE);
                } else {
                  if (e.value == "") {
            FVAR[i].message = "";
                    notifyPoints(i, 0, SOLUTION_NEUTRAL);
                  } else {
            FVAR[i].message = "Ist keine richtige L&#246;sung";
                    notifyPoints(i, 0, SOLUTION_FALSE);
                  }
                }


        break;
              }

            }
            } // closing brace from e==null check
    }



    // if (isTest == true) fillUserField();
}

// Funktion zur Syntaxpruefung von CodeEdit-Feldern
function checkCESyntax(editor,applet) {
    var prg = editor.getValue();
    applet.setViewText(prg);
}

//---------------------------------------------------------------- Funktionen zur LMS-Interaktionen in SCORM-Modulen ------------------------------------------------------------

function ScanParentsForApi(win)
{
      var nParentsSearched = 0;
      while ( (win.API_1484_11 == null) && (win.parent != null) && (win.parent != win) && (nParentsSearched <= 500))
      {
            nParentsSearched++;
            win = win.parent;
      }
      return win.API_1484_11;
}

function GetSCORMApi()
{
      var API = null;
      //Search all the parents of the current window if there are any
      if ((window.parent != null) && (window.parent != window))
      {
            API = ScanParentsForApi(window.parent);
      }
      if ((API == null) && (window.top.opener != null))
      {
            API = ScanParentsForApi(window.top.opener);
      }

      return API;
}

// Parameter: Die globale ID (als string) des Fragefelds, typischerweise mit \MGenerateID erzeugt
// Rueckgabe: Die personalisierte cms-interaction-id fuer dieses Feld des Lerners. Falls noch nicht vorhanden wird eine erzeugt und mit einer leeren Interaktion belegt.
// VERALTET
function GetInteractionID(gid)
{
  if (objScormApi == null) return -1;

  var N = objScormApi.GetValue("cmi.interactions._count");

  var id = -1;
  for (id=0; id<N; id++) {
    var sid = objScormApi.GetValue("cmi.interactions." + id + ".id");
    if (sid == gid) return id;
  }

  // Neue Interaktion im LMS generieren und Werte initialisieren
  objScormApi.SetValue("cmi.interactions." + N + ".id",gid);
  objScormApi.SetValue("cmi.interactions." + N + ".type", "long-fill-in");
  objScormApi.SetValue("cmi.interactions." + N + ".description", "Question id " + gid);
  objScormApi.SetValue("cmi.interactions." + N + ".learner_response", "");
  objScormApi.SetValue("cmi.interactions." + N + ".result","neutral");

  return N;
}

// Parameter: Die globale uxid (als string) des Fragefelds
function GetResult(uxid)
{
  // log.debug('mintscripts_bootstrap: trying to getResult with id', id);
  // result = scores.getSingleScore(id) || null;
  // if (typeof result !== "undefined" && result !== null) {
  //   result = result.rawinput
  // }
  // log.debug('mintscripts_bootstrap: got', result);
  // return result;
  if (intersite.isActive() == true) {
    if (intersite.getObj().configuration.CF_LOCAL == "1") {
      var j = 0;
      for (j = 0; j < intersite.getObj().scores.length; j++) {
    if (intersite.getObj().scores[j].uxid == uxid) {
      return intersite.getObj().scores[j].rawinput;
    }
      }
    }
  }
  return null;
}

// Fuellt alle vorhandenen Fragefelder der Seite mit den gespeicherten Antworten aus dem LMS,
// falls empty==true wird alles mit Leerstrings gefuellt auch wenn API da ist, falls keine API da ist oder Benutzer nicht will gibt es immer Leerstrings
function InitResults(empty)
{
  log.debug("InitResults (empty=" + empty + ", isTest=" + isTest + ") start");
  var f = document.getElementById("TESTEVAL");
  if ((empty==true) & (f != null)) f.innerHTML = "Test ist noch nicht abgeschlossen.";
  if (isTest == true) testFinished = false;

  var i = 0;
  for (i=1; i<FVAR.length; i++) { FVAR[i].prepare(); }

  if (intersite.isActive() == true) {
    if (intersite.getObj().configuration.CF_LOCAL == "0") empty = true; // Benutzer will keine StorageNutzung
  }

  if ((empty==true) || (intersite.isActive()!=true)) {
    for (i = 1; i < FVAR.length; i++) {
      FVAR[i].clear();
    }
  }

  if ((intersite.isActive() == true) && (empty==false)) {
    log.trace("Performing MQuestion-result reload");
    var gid = "";
    var v = "";
    for (i=1; i<FVAR.length; i++) {
      var e = document.getElementById(FVAR[i].id);
      if (FVAR[i].sync == 1) {
        v = GetResult(FVAR[i].uxid);
      } else {
    v = null;
      }

      if (v == null) v = "";
      switch(FVAR[i].type) {

          case 1: {
        // Eingabefeld mit alphanumerischer Loesung, case-sensitive
                e.value = v;
        FVAR[i].rawinput = v;
                check_group(i,i);
                break;
              }

              case 2: {
                // tristate checkbox: indeterminate, true determinate, false determinate (having intersite values "0", "1", "2")
                log.trace("tristate init v = " + v);
                if ((v == "0") || (v == "")) {
                    // nothing selected yet
                    e.cval = "0";
                    e.checked = false;
                    e[getIndeterminatePropName()] = true;
                    FVAR[i].clear();
                }
                if (v == "1") {
                    // yes selected
                    e.cval = "1";
                    e.checked = true;
                    e[getIndeterminatePropName()] = false;
                    check_group(i,i);
                }
                if (v == "2") {
                    // no selected
                    e.cval = "2";
                    e.checked = false;
                    e[getIndeterminatePropName()] = false;
                    check_group(i,i);
                }
                break;
              }

              case 3: {
                // Eingabefeld mit reeller Loesung, geparset, exakt bis auf OPTION Stellen hinter dem Komma, Mengen moeglich, Mengen moeglich
                e.value = v;
                FVAR[i].rawinput = v;
                check_group(i,i);
                break;
              }

              case 4: {
                // Eingabefeld mit Funktionsausdruck als Loesung, geparset, approximierter Vergleich an den Stuetzstellen 1,2,...,Anzahl
                if (v.trim() != "") {
                    e.value = v;
                    FVAR[i].rawinput = v;
                    try {
                        // Eingabe konnte geparset werden
                        var ob = FVAR[i].convertinput();
                        FVAR[i].texinput = notationParser_OUT(ob.latex);
                        FVAR[i].parsedinput = ob.mathjs;
                        FVAR[i].valcode = mathJS.compile(ob.mathjs); // mathjs oder parser? mathjs ist mit konstrukten?
                        FVAR[i].valvalid = true;
                    } catch(e) {
                        // Eingabe konnte nicht geparset werden
                        if (FVAR[i].texinput == "") FVAR[i].texinput = "\\text{(Fehlerhafte Eingabe)}";
                        FVAR[i].parsedinput = "0";
                        FVAR[i].valcode = mathJS.compile("0");
                        FVAR[i].valvalid = false;
                    }
                } else {
                 FVAR[i].texinput = "\\text{(Keine Eingabe)}";
                 FVAR[i].parsedinput = "0";
                 FVAR[i].valcode = mathJS.compile("0");
                 FVAR[i].valvalid = false;
                }






                check_group(i,i);
                break;
              }

          case 6: {
                // Eingabefeld mit Intervall als Loesung
                e.value = v;
                FVAR[i].rawinput = v;
                check_group(i,i);
                break;
          }

          case 7: {
                // Spezialisiertes Eingabefeld
                e.value = v;
                FVAR[i].rawinput = v;
                check_group(i,i);
                break;
          }
      }
    }


  } else {
    // Keine geladenen Daten oder empty==true, alle Felder werden geleert
    for (i=1; i<FVAR.length; i++) { FVAR[i].clear(); } // kein check_group weil sonst eingefaerbt bzw. checkboxen ausgewertet werden, stringbasierte Felder rufen check selbst bei clear auf
  }

}

// Wird auf Testseiten vom Abschluss-Button aufgerufen
function finish_button(name) {
  check_all();
  var f = document.getElementById("TESTEVAL"); // Element vom Typ textarea
  var nMinPoints = 1;
 var ratio = 100 * nPoints / nMaxPoints;
  if (f != null) {
    f.innerHTML = "";
    f.innerHTML += "<strong>" + $.i18n( "msg-completed-test", name) + "</strong><br />"; // name + " wurde abgeschlossen:
    f.innerHTML += $.i18n( "msg-reached-points", nPoints) + "<br />";// Im Test erreichte Punkte: " + nPoints
    f.innerHTML += $.i18n( "msg-max-points", nMaxPoints ) + "<br />"; // "Maximal erreichbare Punkte: " + nMaxPoints
    f.innerHTML += $.i18n("msg-dispatched-test") + "<br /><br />"; // "Der Test wird abgeschickt, wenn mindestens ein Punkt erreicht wurde.
    if (nPoints < nMinPoints) {
      f.innerHTML += "<strong>"+$.i18n("msg-not-dispatched-test")+"</strong><br />"; // Der Test ist noch nicht abgeschickt.
    } else {
      f.innerHTML += $.i18n("msg-submitted-test")+"<br />"; // Test ist eingereicht, kann aber weiter bearbeitet und erneut abgeschickt werden.
    }
    if (SITE_UXID == "VBKMT_AbgebeTest") {
      ratio = Math.round(ratio * 100) / 100;
      f.innerHTML += "<emph>"+$.i18n("msg-reached-point-ratio", ratio)+"</emph><br /><br />";// Es wurden " + ratio + "% der Punkte erreicht!
    }

  }
  if (isTest == true) {
      testFinished = true;

      if ((intersite.isActive()==true) && (intersite.getObj().configuration.CF_TESTS=="1")) {
    	  // whatever this does, if it's false, the page will reload
          intersite.pushIso(true);
          var timestamp = +new Date();
          var cm = "TESTFINISH: " + "CID:" + signature_CID + ", user:" + intersite.getObj().login.username + ", timestamp:" + timestamp + ", testname:" + name + ", nPoints:" + nPoints + ", maxPoints:" + nMaxPoints + ", ratio:" + (nPoints/nMaxPoints) + ", nMinPoints:" + nMinPoints;
          intersite.sendeFeedback({statistics: cm }, true);
          log.trace("Testfinish gesendet");
      }

      if ((doScorm == 1) && (SITE_UXID == "VBKMT_AbgebeTest")) {
        // MatheV4: Gesamtpunktzahl ueber alle ABSCHLUSSTESTS mitteln und Prozentwert an SCORM uebertragen

    log.trace("ENTRYTEST geht an SCORM");
    var mx = 0;
        var mi = 0;
        var av = 0;
        // iterate through questions with test flag outside preparation test

        var psres = pipwerks.SCORM.init();
        log.trace("SCORM init = " + psres);
        psres = pipwerks.SCORM.get("cmi.learner_id");
        log.trace("SCORM learner id = " + psres);
        psres = pipwerks.SCORM.get("cmi.learner_name");
        log.trace("SCORM learner name = " + psres);
        psres = pipwerks.SCORM.set("cmi.interactions.0.id","TEST");
        log.trace("SCORM set interact_id = " + psres);
        psres = pipwerks.SCORM.set("cmi.interactions.0.learner_response",nPoints);
        log.trace("SCORM set interact_lr = " + psres); // false im KIT-ILIAS
        psres = pipwerks.SCORM.set("cmi.interactions.0.result",true);
        log.trace("SCORM set interact_res = " + psres); // false im KIT-ILIAS
        psres = pipwerks.SCORM.set("cmi.score.raw",nPoints);
        log.trace("SCORM set rawpoints = " + psres);
        psres = pipwerks.SCORM.set("cmi.score.min",nMinPoints);
        log.trace("SCORM set minpoints = " + psres);
        psres = pipwerks.SCORM.set("cmi.score.max",nMaxPoints);
        log.trace("SCORM set maxpoints = " + psres);
        psres = pipwerks.SCORM.set("cmi.score.scaled",(nPoints/nMaxPoints));
        log.trace("SCORM set scaled points = " + psres);

        psres = pipwerks.SCORM.set("cmi.objectives.0.id","Abschlusstests");
        log.trace("SCORM set objectives = " + psres);
        psres = pipwerks.SCORM.set("cmi.objectives.0.raw",nPoints);
        log.trace("SCORM set obrawpoints = " + psres); // false im KIT-ILIAS
        psres = pipwerks.SCORM.set("cmi.objectives.0.min",nMinPoints);
        log.trace("SCORM set obminpoints = " + psres); // false im KIT-ILIAS
        psres = pipwerks.SCORM.set("cmi.objectives.0.max",nMaxPoints);
        log.trace("SCORM set obmaxpoints = " + psres); // false im KIT-ILIAS
        psres = pipwerks.SCORM.set("cmi.objectives.0.scaled",(nPoints/nMaxPoints));
        log.trace("SCORM set obscaled = " + psres); // false im KIT-ILIAS
        psres = pipwerks.SCORM.set("cmi.objectives.0.completion_status", (nPoints>=nMinPoints) ? ("completed") : ("incomplete") );
        log.trace("SCORM set obcompletion " + psres);

        psres = pipwerks.SCORM.set("cmi.scaled_passed_score", nMinPoints/nMaxPoints);
        log.trace("SCORM set obscossc " + psres); // false im KIT-ILIAS
        psres = pipwerks.SCORM.set("cmi.score", nPoints/nMaxPoints );
        log.trace("SCORM set obscore " + psres); // false im KIT-ILIAS


        psres = pipwerks.SCORM.set("cmi.progress_measure",(nPoints/nMaxPoints));
        log.trace("SCORM set progress measure = " + psres);
        psres = pipwerks.SCORM.set("cmi.success_status", (nPoints>=nMinPoints) ? ("passed") : ("failed") );
        log.trace("SCORM set obcomp = " + psres);
        psres = pipwerks.SCORM.set("cmi.completion_status", (nPoints>=nMinPoints) ? ("completed") : ("incomplete") );
        log.trace("SCORM set completion " + psres);
        psres = pipwerks.SCORM.save();
        log.debug("SCORM save = " + psres);
        if (psres==true) f.innerHTML += $.i18n("msg-transfered-result")+"\n"; // Die Punktzahl wurde zur statistischen Auswertung übertragen

      }


  }
}

function reset_button()
{
  log.debug("reset_button start");
  InitResults(true);
}

/**
 * TODO watch out FVAR is a html element with very many fields.... extract the needed ones and
 * do not set extra variables on it ...
 * @param  {[type]} i      [description]
 * @param  {[type]} points [description]
 * @param  {[type]} state  [description]
 * @return {[type]}        [description]
 */
function notifyPoints(i, points, state) {
  log.trace('mintscripts_bootstrap: notify points called with parameters', i, points, state);
  log.trace('mintscripts_bootstrap: you just changed the answer for', FVAR[i]);
  FVAR[i].points = points;
  if ((isTest == true) && (FVAR[i].sync == 1)) {
    nPoints += points;
    nMaxPoints += FVAR[i].maxpoints;
  }
  if ((intersite.isActive() == true) && (FVAR[i].sync == 1)) {
      if ((intersite.getObj().configuration.CF_LOCAL == "1") && (intersite.getObj().configuration.CF_TESTS == "1")) {
          var f = false;
          var j = 0;

          //add missing fields to FVAR[i]
          // var newScoreObj = {};
          // newScoreObj.points = points;
          // newScoreObj.siteuxid = SITE_UXID;
          // newScoreObj.state = state;
          // newScoreObj.maxpoints = FVAR[i].maxpoints;
          // newScoreObj.siteuxid = SITE_UXID;
          // newScoreObj.section = FVAR[i].section;
          // newScoreObj.id = FVAR[i].id;
          // newScoreObj.uxid = FVAR[i].uxid;
          // newScoreObj.intest = FVAR[i].intest;
          // newScoreObj.rawinput = FVAR[i].rawinput;
          // newScoreObj.value = FVAR[i].value;
          //
          // scores.setSingleScore(FVAR[i].id, newScoreObj);
          //also hier wird ein einzelner score geupdated
          for (j = 0; j<intersite.getObj().scores.length; j++) {
              if (intersite.getObj().scores[j].uxid == FVAR[i].uxid) {
                  f = true;
                  intersite.getObj().scores[j].maxpoints = FVAR[i].maxpoints;
                  intersite.getObj().scores[j].points = points;
                  intersite.getObj().scores[j].siteuxid = SITE_UXID;
                  intersite.getObj().scores[j].section = FVAR[i].section;
                  intersite.getObj().scores[j].id = FVAR[i].id;
                  intersite.getObj().scores[j].uxid = FVAR[i].uxid;
                  intersite.getObj().scores[j].intest = FVAR[i].intest;
                  intersite.getObj().scores[j].rawinput = FVAR[i].rawinput;
                  intersite.getObj().scores[j].value = FVAR[i].value;
                  intersite.getObj().scores[j].state = state;
                  log.trace("Points for " + SITE_UXID + "->" + FVAR[i].uxid + " modernized, rawinput = " + intersite.getObj().scores[j].rawinput);
              }
          }

          // und hier hinzugefügt
          // das f == false kann vermutlich auch weg weil jetzt immer die gleiche funktion updateScore benutzt wird
          // die einfach setzt
          if (f == false) {
            //scores.setSingleScore(FVAR[i].id, FVAR[i]);
            var k = intersite.getObj().scores.length;
            intersite.getObj().scores[k] = { uxid: FVAR[i].uxid };
            intersite.getObj().scores[k].maxpoints = FVAR[i].maxpoints;
            intersite.getObj().scores[k].points = points;
            intersite.getObj().scores[k].siteuxid = SITE_UXID;
            intersite.getObj().scores[k].section = FVAR[i].section;
            intersite.getObj().scores[k].id = FVAR[i].id;
            intersite.getObj().scores[k].intest = FVAR[i].intest;
            intersite.getObj().scores[k].value = FVAR[i].value;
            intersite.getObj().scores[k].rawinput = FVAR[i].rawinput;
            intersite.getObj().scores[k].state = state;
            log.trace("Points for " + FVAR[i].uxid + " ADDED at position " + k);
          }
      }
  }

  // Feldeigenschaften entsprechend anpassen
  FVAR[i].displayFeedback(state);
  updateLayoutStates();

}


function globalunloadHandler() {
  if (timerActive) {
      window.clearInterval(timerVar);
      timerActive = false;
  }

  intersite.pushIso(true); // nur synchrone ajax-calls erlauben, da wir im unload-Handler sind und die callbacks sonst verschwinden bevor Aufruf beantwortet wird

  // VERALTET
  if (pipwerks.scormdata.connection.isActive == true)
  {
    log.trace("pipwerks.scormdata.connection.isActive == true in globalunloadHandler");
    pipwerks.SCORM.save();

  } else {
    log.trace("pipwerks.scormdata.connection.isActive == false in globalunloadHandler");
  }
}

function globalloadHandler(pulluserstr) {
  // Wird aufgerufen, wenn die Seite komplett geladen ist (NACH globalready) ODER durch pull-emit-callback wenn intersite.getObj() aktualisiert werden muss
  // Ab diesem Zeitpunkt steht das DOM komplett zuer verfuegung
  log.debug("globalLoadHandler start, pulluser = " + ((pulluserstr == "") ? ("\"\"") : ("userdata")));
  if (pulluserstr != "") {
    intersite.setup(false, pulluserstr); // kann durch nach dem load stattfindende Aufrufe von intersite.setup ueberschrieben werden, z.B. wenn das intersite-Objekt von einer aufrufenden Seite uebergeben wird
    log.debug("intersite.setup in loadhandler fertig");

    if (intersite.isActive() == true) {
      if (variant != intersite.getObj().login.variant) {
        // abort site setup, switch to needed variant tree
        selectVariant(intersite.getObj().login.variant);
      }
    }

    applyLayout(false);
    log.debug("Layout gesetzt in loadhandler");

    InitResults(false);

    log.debug("Results eingetragen");

  }

  if (timerActive == false) {
      timerActive = true;
      timerVar = window.setInterval(globalTimerHandler, timerMillis);
  }

  log.debug("globalLoadHandler finish");
}

function globalreadyHandler(pulluserstr) {
  // Wird aufgerufen, wenn die Seite komplett geladen und alle Bilder/iframes gefuellt sind (VOR globalload, NACH direkt-JS-Befehlen auf html-Seite im body-Bereich oder eingebundenen js-Dateien) ODER durch pull-emit-callback wenn intersite.getObj() aktualisiert werden muss
  // Ab diesem Zeitpunkt steht das DOM komplett zuer verfuegung
  log.debug("globalreadyHandler start");
  // emit JSON companion load request if present, use preset sitejson otherwise
  // this should specify a success handler, or catch failures
  if (sitejson_load) {
      $.getJSON(docName + ".json", function(data) {
          sitejson = data;
          log.debug("companion object retrieved");
        });
  }
  // setup intersite objects
  intersite.setup(false, pulluserstr); // kann durch nach dem load stattfindende Aufrufe von intersite.setup ueberschrieben werden, z.B. wenn das intersite-Objekt von einer aufrufenden Seite uebergeben wird

  if (intersite.isActive() == true) {
    if (variant != intersite.getObj().login.variant) {
      // abort site setup, switch to needed variant tree
      selectVariant(intersite.getObj().login.variant);
    }
  }

  // setup intersite objects
  log.debug("intersite.setup fertig");
  applyLayout(true);
  log.debug("Layout gesetzt");
  InitResults(false);
  log.debug("Results eingetragen");
  log.debug("globalreadyHandler finish");
}

// VERALTET
function fillUserField() {
  log.debug("fillUserField start");
  if (isTest == true) {
    var e = document.getElementById("UFID");
    if (e != null) {
      if (lName != "") {
    e.value = lName + "\n(ID: " + lID + ")";
      } else {
    e.value = "<"+$.i18n("ui-not-loggedin")+">";// Nicht angemeldet
      }

      if (nPoints > 0) {
    if (nMaxPoints > 0) {
      e.value += "\n" + $.i18n("ui-max-points", nPoints, nMaxPoints)//"\nPunkte erreicht: " + nPoints + " von " + nMaxPoints;
    } else {
      e.value += "\n" + $.i18n("ui-reached-points", nPoints )// "\nPunkte erreicht: " + nPoints;
    }
      } else {
    if (nMaxPoints > 0) {
      e.value += "\n" + $.i18n("ui-necessary-points", nMaxPoints); // "\nPunkte zu erreichen: " + nMaxPoints;
    }
      }
      e.readOnly = true;
    }
  }
}

// Ermittelt die vertikale Scrollposition des Browsers
function getScrollY() {
    var scrOfY = 0;

    if( typeof( window.pageYOffset ) == 'number' ) {
        //Netscape compliant
        scrOfY = window.pageYOffset;
        scrOfX = window.pageXOffset;

    } else if( document.body && ( document.body.scrollLeft || document.body.scrollTop ) ) {
        //DOM compliant
        scrOfY = document.body.scrollTop;
        scrOfX = document.body.scrollLeft;

    } else if( document.documentElement && ( document.documentElement.scrollLeft || document.documentElement.scrollTop ) ) {
        //IE6 standards compliant mode
        scrOfY = document.documentElement.scrollTop;
        scrOfX = document.documentElement.scrollLeft;
    }
    return scrOfY;
}

function getGlobalValue(varname) {
  // MVAR-Array wird im Gegensatz zu FIELD von 0 an nummeriert
  var i;
  for (i=0; i<MVAR.length; i++) {
    if (MVAR[i].vname == varname) {
      return MVAR[i].value();
    }
  }
  return 0;
}

function rerollMVar(varname) {
  // MVAR-Array wird im Gegensatz zu FIELD von 0 an nummeriert
  var i;
  for (i=0; i<MVAR.length; i++) {
    if (MVAR[i].vname == varname) {
      MVAR[i].reroll();
      var j = 0;
      for (j=0; j<MVAR[i].deps.length; j++) {
    MVAR[i].deps[j].valueHasMutated();
      }
      check_group(1,FVAR.length-1);
      return MVAR[i].value();
    }
  }

  return 0;
}

// Registriert ein Variablenabhaengiges div das MathJax-generierten Mathematikausdruecke anzeigt
// Variablen werden ueber Observablen repraesentiert, deren Aenderung triggert das Update des divs
// Eingabe: Die Formel als LaTeX-String ggf. mit \MVar-Kommandos und das observable-"Objekt"
function registerVariables(texmath,obsobj) {
  var i = 0;
  for (i=0; i<MVAR.length; i++) {
    var s = MVAR[i].vname;
    if (texmath.search("[var_" + s + "]") != -1) {
      MVAR[i].deps.push(obsobj);
    }
  }
}


// --------------------------- Das Eingabefenster fuer Formelfelder -----------------------------------------------

// Stellt in einem separaten Bereich den content des Felds dar.
// Es kann immer nur ein Eingabefeld aktiv sein.


function closeInputContent() {
    viewmodel.ifobs("");
    var u = document.getElementById("UFIDM");
    if (u != null) {
      u.value = "";
    }
    if (activefieldid != "") {
        if (activetooltip == null) {
      log.debug("activefieldid ohne tooltip!");
    } else {
      var api = activetooltip.qtip("api");
      api.toggle(false);
      api.destroy();
      activetooltip = null;
    }
        activefieldid = "";
    }
}

function displayInputContent(id,latex) {
    latex = "\\displaystyle\\large " + latex;
    activefieldid = FVAR[id].id;
    log.debug( "mintscripts_bootstrap: displayInputContent " + latex + " in " + activefieldid);

    if (activetooltip != null) {
    	// Tooltip ist schon da
        log.debug("mintscripts_bootstrap: activetooltip != null");
    } else {
      // Neuer Tooltip wird erzeugt und an das input-Element geklebt, bei Tests keine Kommentare dazu abhaengig vom Status des Tests
      var content = "";
      log.debug("mintscripts_bootstrap: activetooltip == null");
      if ((isTest == false) | (testFinished == true)) {
	    content = '<div id="NINPUTFIELD' + activefieldid + '" data-bind="evalmathjax: ifobs"></div><br /><div name="NUSERMESSAGE" id="UFIDM' + activefieldid + '" style="line-height:110%; color:#000000; border: thin solid rgb(0,0,0); padding: 8px; background-color:#CFDFDF; width:250px; font-size:11pt; font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", Verdana, Arial, Helvetica , sans-serif;"></div>';
      } else {
	    content = '<div id="NINPUTFIELD' + activefieldid + '" data-bind="evalmathjax: ifobs"></div><br />' + $.i18n("ui-missing-tooltip");
      }
      log.debug( "mintscripts_bootstrap: ", content);
      activetooltip = $(" input[id=\"" + activefieldid + "\"] ").qtip({
	    id: 'activetooltip',
	    show: {event: 'customShow' },
	    hide: {event: 'customHide' },
	        content: '...',
	        events: {
	          show: function(event, api) {

            },
	          hide: function(event, api) {
            }

	        },
	        style: {
	          classes: 'qtip-shadow'
	        },
	    	position: {
	    		my: 'top left',  // Position my top left...
	            at: 'bottom left' // at the bottom right of...
	    	}
      });
      log.debug( "mintscripts_bootstrap: ", activetooltip);

      var api = activetooltip.qtip("api");
      api.set('content.title',"Formeleingabe");
      api.set('content.text',content);

      log.debug('testtest', content);
      // api.set("position.target",$(" input[id=\"" + activefieldid + "\"] "));
      // api.reposition(null,false);
      api.show();


      // api.reposition(null,false);

    }

    viewmodel.ifobs(latex);
    log.debug("mintscripts_bootstrap: activefieldid " + activefieldid);
    var element = document.getElementById("NINPUTFIELD" + activefieldid);
    log.debug("mintscripts_bootstrap:", element);
    if (element.childNodes[0]) {
        // Element ist schon da und wir nur upgedated
        // var sy = getScrollY();
        var mathelement = MathJax.Hub.getAllJax(element)[0];
        MathJax.Hub.Queue(["Text",mathelement,latex]);
        // setScrollY(sy);
    } else {
        // Element wird im qtip komplett neu angelegt und getypesettet
        // while(element.childNodes[0]) { element.removeChild( element.childNodes[0] ); }
        log.debug("mintscripts_bootstrap: create element");

        var s = document.createElement('script');
        s.type = "math/tex; mode=display";
        try {
          s.appendChild(document.createTextNode(latex));
          element.appendChild(s);
        } catch (e) {
          s.text = latex;
          element.appendChild(s);
        }
        MathJax.Hub.Queue(["Typeset",MathJax.Hub,element]);
    }

}


// --------------------------------------------- Borkifier ---------------------------------------

function permuteString(str, u) {
  var n = str.length;
  var t = "";

  var i;
  for (i = 0; i < n; i++) {
    t += str.charAt((u*i) % n);
  }

  return t;
}


function debork(str, l) {
  var n = str.length;
  u = (((5*n) - (3*l)) % n);
  while (mygcd(u,n) != 1) { u = ((u + 1) % n);}

  var i = 0;
  while ( ((i*u) % n) != 1) { i++; }

  str = permuteString(str, i);
  return str.slice(0,l);
}

// ----------------------------------------------- Variant management ---------------------------

function selectVariant(v) {
  log.debug("Variant selected: " + v);

  var ex1 = outputWebdir;
  var raw = outputWebdir;

  if (ex1.indexOf("_") != -1) {
      raw = ex1.substr(0, ex1.indexOf("_"));
  }

  var ex2 = raw;
  if (v != "std") {
      ex2 = ex2 + "_" + v;
  }

  t = window.location.href;
  s = t.replace("/" + ex1 + "/", "/" + ex2 + "/");

  if (intersite.isActive()) {
      intersite.getObj().login.variant = v;
  }

  opensite(s); // same site in different output directory
}

// ----------------------------------------------- Roulette-Fragen ------------------------------

// DirectRoulettes


// rid = eindeutige ID des Roulettes, id = Nummer der Einzelaufgabe, maxid = Anzahl Aufgaben (letzte hat id maxid-1)
function rouletteClick(rid, id, maxid) {
    log.debug("rouletteClick: rid=" + rid + ", id=" + id + ", maxid=" + maxid);
    // select a random div
    var d = Math.floor((Math.random() * maxid));
    log.trace("Selected d=" + d);
    // get div for the question as a string from the roulette hash's array
    s = sitejson["_RLV_" + rid][d];
    log.trace("Retrieved divstring");
    // set container to hidden, write new HTML inset content, enable container and display it
    $("#" + "ROULETTECONTAINER_" + rid).css("visibility", "hidden").html(s).prop('disabled', false).css("visibility", "visible");
    // call MathJax to typeset new content
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, "ROULETTECONTAINER_" + rid]);
}

// Datenbank-Roulettes


// Callbacks fuer roulette getCollection

function rid_success(data) {
    var s = JSON.stringify(data);
    log.trace("rid_success: " + s);
}

function rid_error(message, data) {
    log.trace("rid_error: " + message + ", data = " + JSON.stringify(data));
}
// Liefert den HTML-Text einer zufaellig ausgewaehlten Aufgabe aus der Collection zur gegebenen id vom exerciseserver
function rouletteExercise(rid) {
  exercises.getCollection(rid, rid_success, rid_error);
}

// ---------------------- Funktionen fuer Seitenverhalten/Frames -------------------------------------------

function styleColors(c) {
  if (c.length == 6) {
    if (intersite.isActive() == true) {
      if (intersite.getObj() != null) {
        if (typeof intersite.getObj().configuration.stylecolor == "string") {
      if (intersite.getObj().configuration.stylecolor == STYLEGREEN) {
        c = c.substr(0,2) + c.substr(4,2) + c.substr(2,2);
      } else {
        if (intersite.getObj().configuration.stylecolor == STYLERED) {
          c = c.substr(4,2) + c.substr(0,2) + c.substr(2,2);
        } else {
              if (intersite.getObj().configuration.stylecolor == STYLEGREY) {
            c = c.substr(4,2) + c.substr(4,2) + c.substr(4,2);
          }
        }
      }
        } else {
      log.debug("No stylecolor found in configuration");
        }
      }
    }
  }
  return c;
}

/**
 * Change the text of the login button:
 * Logged -in or -out?
 */
function updateLoginButton() {
    if( userdata.isLoggedIn() ) {
    	$('#logged_out_buttons').hide();
    	$('#logged_in_buttons').show();

    } else {
    	$('#logged_in_buttons').hide();
    	$('#logged_out_buttons').show();
    }
}

/**
 * Change the look of the tool buttons (glossar, data etc.):
 * Logged -in or -out?
 */
function updateToolButtons() {
    if( userdata.isLoggedIn() ) {
    	$('#databutton').removeClass( 'disabled' );

    } else {
    	$('#databutton').addClass( 'disabled' );
    }
}

/**
 * If on the signup page, display the user data if available
 *
 * This only makes sense on the signup/myaccount page.
 * Login Buttons on the signup page are hidden in CSS
 * But the title of the page is toggled here (as it is difficult to test for the absence of a class)
 */
function updateSignupPage() {
	if( SITE_UXID == "VBKM_MISCSETTINGS" ) {
	    if( userdata.isLoggedIn() ) {
	    	$( 'body' ).addClass( 'logged_in' )
	    	$('#pageTitle_logged_out').hide();
	    	$('#pageTitle_logged_in').show();
			$('#USER_VNAME').attr( 'readonly', true );
			$('#USER_SNAME').attr( 'readonly', true );
			$('#USER_EMAIL').attr( 'readonly', true );
			$('#USER_SGANG').attr( 'readonly', true );
			$('#USER_UNI').attr( 'readonly', true );

	    } else {
	    	$( 'body' ).removeClass( 'logged_in' )
	    	$('#pageTitle_logged_in').hide();
	    	$('#pageTitle_logged_out').show();
	    }

		var login = intersite.getObj().login;
		$('#USER_VNAME').val( login.vname );
		$('#USER_SNAME').val( login.sname );
		$('#USER_EMAIL').val( login.email );
		$('#USER_SGANG').val( login.sgang );
		$('#USER_UNI').val( login.uni );
	}
}

// first = false -> Seite wurde schonmal mit Layout aufgesetzt, Layout soll nur angepasst werden
function applyLayout(first) {

  updateLayoutStates();
  updateLoginButton();
  updateToolButtons();
  updateSignupPage();

  var e = document.getElementById("dynamic_css");
  if (e == null) {
    e = document.createElement('style');
    e.setAttribute("id", "dynamic_css");
    document.body.appendChild(e);
  }

  // change layout parameters according to user settings
  if (false) {
	  if (intersite.isActive() === true) {
	    SIZES.BASICFONTSIZE = SIZES.STARTFONTSIZE + intersite.getObj().layout.fontadd;
	    SIZES.SMALLFONTSIZE = SIZES.BASICFONTSIZE - 2;
	    SIZES.BIGFONTSIZE = SIZES.BASICFONTSIZE + 2;
	    SIZES.MENUWIDTH = 160 + 10 * intersite.getObj().layout.fontadd;
	    SIZES.TOCWIDTH = SIZES.MENUWIDTH - 21;
	  }

	  if (intersite.isActive()) {
	    if (intersite.getObj().layout.menuactive == false) hideNavigation(false);
	  }

	  var d = 10 + SIZES.BASICFONTSIZE;
	  $('div.headmiddle').height(d);
	  var systyle = "style=\"max-height:" + d + "px;height:" + d + "px\"";
	  var icstyle = "style=\"width:" + (d-2) + "px;height:" + (d-2) + "px;max-height:" + (d-2) + "px\"";

	  d = d - 2;
	  var head = "<a style=\"max-height:" + d + "px\" href=\"" + linkPath + "config.html\" class=\"MINTERLINK\"><div id=\"loginbutton\" style=\"max-height:" + d + "px;height:" + d + "px;display:inline-block\" class=\"tocminbutton\">"+$.i18n("ui-login")+"</div></a>";
	  var loginbuttontext = $.i18n("ui-loginbutton");//"Zum Kurs anmelden";
	  var loginbuttonhint = $.i18n("hint-loginbutton");//"Hier können Sie sich zum Kurs persönlich anmelden, im Moment wird der Kurs anonym bearbeitet.";
	  var loginbuttonhtml = "<a style=\"max-height:" + d + "px\" href=\"" + linkPath + "config.html\" class=\"MINTERLINK\"><div id=\"loginbutton\" style=\"max-height:" + d + "px;height:" + d + "px;display:inline-block\" class=\"tocminbutton\">" + loginbuttontext + "</div></a>";
	  if (intersite.isActive()) {
	      if (intersite.getObj().login.type >= 2) {
	          loginbuttontext = $.i18n( "logout", getNameDescription() ); // "Logout (" + getNameDescription() + ")";
	          loginbuttonhint = $.i18n( "hint-logout", intersite.getObj().login.username ); //"Der Kurs wird geschlossen und die eingegebenen Daten für Benutzer " + intersite.getObj().login.sname + " gespeichert.";
	          loginbuttonhtml = "<a style=\"max-height:" + d + "px\" href=\"" + linkPath + "logout.html\" class=\"MINTERLINK\"><div id=\"loginbutton\" style=\"max-height:" + d + "px;height:" + d + "px;display:inline-block\" class=\"tocminbutton\">" + loginbuttontext + "</div></a>";
	      }
	  }
  }
  var head = loginbuttonhtml;

  if (intersite.isActive()) {
      if ((intersite.getObj().login.type >= 2) && (intersite.isScormEnv() == 0)) {
          head += "&nbsp;<a style=\"max-height:" + d + "px\" href=\"" + linkPath + "config.html\" class=\"MINTERLINK\"><div id=\"confbutton\" style=\"max-height:" + d + "px;height:" + d + "px;display:inline-block\" class=\"tocminbutton\">" + $.i18n( "msg-myaccount" ) + "</div></a>";
      }
  }

  if (intersite.isScormEnv() == 0) {
      $('.show_scorm').css("display", "none");
      $('.show_noscorm').css("display", "block");
  } else {
      $('.show_scorm').css("display", "block");
      $('.show_noscorm').css("display", "none");
  }

  // head += "<a style=\"max-height:" + d + "px\" href=\"" + linkPath + "cdata.html\" class=\"MINTERLINK\"><div id=\"cdatabutton\" style=\"max-height:" + d + "px;height:" + d + "px;display:inline-block\" class=\"tocminbutton\">Kursdaten</div></a> ";
  /*
  head += "<div id=\"LOGINROW\" style=\"color:rgb(255,255,255)\"></div>";

  head += "<a id=\"listebutton\" href=\"" + linkPath + "search.html\" ></a>";
  head += "<a id=\"homebutton\" href=\"" + linkPath + "index.html\" ></a>";
  head += "<button id=\"starbutton\" " + systyle + " class=\"symbolbutton\" type=\"button\" onclick=\"starClick();\"></button>";
  head += "<button id=\"minusbutton\" " + systyle + " class=\"symbolbutton\" type=\"button\" onclick=\"changeFontSize(-5);\"></button>";
  head += "<button id=\"plusbutton\" " + systyle + " class=\"symbolbutton\" type=\"button\" onclick=\"changeFontSize(5);\"></button>";
  if (intersite.isScormEnv() == 0) {
      head += "<button id=\"sharebutton\" " + systyle + " class=\"symbolbutton\" type=\"button\" onclick=\"shareClick();\"></button>";
  }
  head += "<button id=\"settingsbutton\" " + systyle + " class=\"symbolbutton\" type=\"button\" onclick=\"toggle_settings();\"></button>";

  head += "<button id=\"menubutton\" " + systyle + " class=\"symbolbutton\" type=\"button\" onclick=\"menuClick();\"></button>";
*/
/*
  $('div.headmiddle').each(function(i) {
      $(this).html(head);
    }
  );
 */
/*
  $('.navi > ul > li').each(function(i) {
    $(this).hover(function() { $(this).css("background-color", COLORS.TOCMINBUTTONHOVER); }, function() { $(this).css("background-color", COLORS.TOCMINBUTTON); });
  });
*/
  // set proper button visibility in settings depending on course variant

  if (doScorm == 1) {
      // no variant switching in SCORM versions (because variants are actually different courses)
      $('#variantselect_unotation').prop("disabled", true);
      $('#variantselect_unotation').text('(in diesem Kurs nicht vorhanden)');

  } else {
      if (variant == "std") {
          $('#variantselect_std').css("visibility", "hidden");
          $('#variantactive_std').css("visibility", "visible");
          $('#variantselect_unotation').css("visibility", "visible");
          $('#variantactive_unotation').css("visibility", "hidden");

      } else {
          $('#variantselect_std').css("visibility", "visible");
          $('#variantactive_std').css("visibility", "hidden");
          $('#variantselect_unotation').css("visibility", "hidden");
          $('#variantactive_unotation').css("visibility", "visible");
      }
  }

  var shareintext = $.i18n("msg-shared-page") + "<br /><br />"; // Seite teilen über:
  var myurl = window.location.href;

  shareintext += "<a href=\"#\" onclick=\"shareFacebook()\"><img src=\"" + imagesPath  + "sharetargetfacebook.png\"></a>";
  shareintext += "&nbsp;";
  shareintext += "<a href=\"http://twitter.com/intent/tweet?url=" + myurl + "\" target=\"_new\"><img src=\"" + imagesPath + "sharetargettwitter.png\"></a>";
  shareintext += "&nbsp;";
  shareintext += "<a href=\"https://plus.google.com/share?url=" + myurl + "\" target=\"_new\"><img src=\"" + imagesPath + "sharetargetgoogleplus.png\"></a>";
  showHint($('#sharebutton'), shareintext);

  shareintext = $.i18n("msg-current-favorites")+"<br /><br />"; // Aktuelle Favoriten:
  showHint($('#starbutton'), shareintext);

  // qtips an die Feedbackbuttons haengen falls vorhanden

  $("button[ttip='1']").qtip({
         position: { target: 'mouse', adjust: { x: 5, y: 5 } },
         style: { classes: 'qtip-blue qtip-shadow' },
         content: { attr: 'tiptitle' },
         show: { event: "mouseenter" }
  });

  // enable tristate checkboxes (but only those used for exercises)
  var $check = $("input[mtristate=1]"), el;
  $check
   .prop("mtristate", "2") // don't set function again
   .click(function(e) {


        el = $(this);

        // states are indeterminate, true determinate, false determinate (having intersite values "0", "1", "2", which we store in property "cval")

        switch(el.prop('cval')) {

            // unchecked ->  indeterminate
            case "2":
                el.prop('cval', "0");
                el.prop(getIndeterminatePropName(), true);
                el.prop('checked', false); // remember indeterminate is independent of checked
                break;

            // checked -> unchecked
            case "1":
                el.prop('cval', "2");
                el.prop(getIndeterminatePropName(), false);
                el.prop('checked', false);
                break;

            // indeterminate -> checked
            default:
                el.prop('cval', "1");
                el.prop(getIndeterminatePropName(), false);
                el.prop('checked', true);
                break;
        }


});

//  setupInterlinks()
}

/**
 * Change the base font size for the page. Called by zoom buttons.
 *
 * @param add - a positive or negative number (any number will do, the exact value has no meaning)
 */
function changeFontSize(add) {
  sizes = [ "smaller", "small", "medium", "large" ];
  sizeDefault = "medium";
  current = document.body.style.fontSize;
  if ( typeof( current ) == 'undefined' ) current = sizeDefault;
  i = sizes.indexOf( current );
  if ( i < 0 || i >= sizes.length ) i = sizes.indexOf( sizeDefault );

  if ( add > 0 ) {
	  newI = Math.min ( i + 1, sizes.length-1 )

  } else {
	  newI = Math.max ( i - 1, 0 )

  }
  document.body.style.fontSize = sizes[ newI ];
}

function hideNavigation(animate) {
  var speed;
  if (animate == true) speed = animationSpeed; else speed = 0;
  $('div.navi').slideUp(speed);
  $('tocnavsymb').hide();
  $('div.toc').animate({width: 'hide'}, speed);
  $('#footerleft').slideUp(speed / 3);
  $('#footermiddle').slideUp(speed / 3);
  $('#footerright').slideUp(speed / 3);
  $('#footer').hide();
  $('#content').css("margin-left","0px");
  if (intersite.isActive()) intersite.getObj().layout.menuactive = false;
}

function showNavigation(animate) {
  var speed;
  if (animate == true) speed = animationSpeed; else speed = 0;
  $('#content').css("margin-left",SIZES.MENUWIDTH + "px");
  $('#footer').show();
  $('#footerleft').slideDown(speed / 3);
  $('#footermiddle').slideDown(speed / 3);
  $('#footerright').slideDown(speed / 3);
  $('div.toc').animate({width: 'show'}, speed);
  $('tocnavsymb').show();
  $('div.navi').slideDown(speed);
  if (intersite.isActive()) intersite.getObj().layout.menuactive = true;
}

function menuClick() {
    if ($('div.navi').is(":visible")) {
        hideNavigation(true);
    } else {
        showNavigation(true);
    }
}

// Zeigt einmalig einen Hinweis fuer ein Bedienelement an und merkt sich im intersite.getObj() dass der hint gezeigt wurde
// Hinweis wird bei laengerem Hover wieder eingeblendet
function showHint(element, hinttext) {

  if (element == null) return;

  var q_at = "bottom left";
  var q_my = "top right";

  if (typeof element.offset == 'function') { // some buttons don't seem to provide it
      off = element.offset(); // and some provide a null
      if (off != null) {
          if (element.offset().left < 200) {
              // element is too far on the left side, so tooltip should be to the right side
              q_at = "bottom right";
              q_my = "top left";
          }
      }
  }

  hinttext = "<div style=\"font-size:" + SIZES.SMALLFONTSIZE + "px;line-height:100%\">" + hinttext + "</div>";

  // Check if qtip is already attached to the element
  if(typeof element.data('qtip') === 'object') {
    element.qtip('option', 'content.text', hinttext);
  } else {
    element.qtip({
       content: { text: hinttext },
       show: { delay: 500 },
       hide: { delay: 100, fixed: true },
       position: {
           my: q_my,
           at: q_at,
           target: element
       },
       style: { classes: 'qtip-yellow'}
    });
  }
}

function shareClick() {
//  $('#sharebutton').qtip("toggle","true");
}

function starClick() {
  // opensite(linkPath + "favor.html");
}


function shareFacebook() {
  window.open(
    'https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(location.href),
    'facebook-share-dialog',
    'width=626,height=436');
}

// TODO changes classes of toc/navi elements to show element state (element behaviour is defined in css)
// TODO this is currently not working and that is because (one reason) the other data structure of scores.
// was array now is obj with questionId keys
// TODO this function is called too often (> 10 times), should be called once
function updateLayoutStates() {
  log.debug('ms_bs: updateLayoutStates called');
  log.debug(intersite.isActive(), intersite.getObj());
  if (intersite.isActive() == true) {
    if (intersite.getObj() != null) {
        // check sites and select layout state accordingly
        $('.xsymb').each(function(i) {
          log.debug('ms_bs: updateLayoutStates each .xsymb', $(this));
            el = $(this);
            ux = "SITE_" + el.attr("uxid");
            var j;
            var found = false;
            for (j = 0; ((j < intersite.getObj().sites.length) && !found); j++) {
                if (intersite.getObj().sites[j].uxid == ux) {
                    found = true;
                }
            }
            if (found) {
                // check exercise points to determine state of the element
                var k;
                var maxpoints = 0;
                var points = 0;
                var sfound = false;



                // no exercises present or all in neutral state: no state
                // at least one exercise in false state: problem
                // all exercises in true state: done
                // otherwise: progress (some exercises done, some in true state, none in false state)

                alldone = true;
                allneutral = true;
                prob = false;
                for (k = 0; k < intersite.getObj().scores.length; k++) {
                    if (intersite.getObj().scores[k].siteuxid == el.attr("uxid")) {
                        sfound = true;
                        maxpoints += intersite.getObj().scores[k].maxpoints;
                        points += intersite.getObj().scores[k].points;
                        if (intersite.getObj().scores[k].state == SOLUTION_FALSE) {
                            prob = true;
                            alldone = false;
                            allneutral = false;
                        } else {
                            if (intersite.getObj().scores[k].state == SOLUTION_NEUTRAL) {
                                alldone = false;
                            } else {
                                allneutral = false;
                            }
                        }
                    }
                }

                var msg = "";
                if ((sfound == false) || (allneutral == true) || (maxpoints == 0)) {
                    el.toggleClass("state_progress", false);
                    el.toggleClass("state_done", false);
                    el.toggleClass("state_problem", false);
                } else {
                    d = Math.floor((1.0 * points) / (1.0 * maxpoints) * 100.0);
                    if (prob) {
                        el.toggleClass("state_progress", false);
                        el.toggleClass("state_done", false);
                        el.toggleClass("state_problem", true);
                        msg = MESSAGE_PROBLEM  + " (" + d + "%)";
                    } else {
                        if (alldone) {
                            el.toggleClass("state_progress", false);
                            el.toggleClass("state_done", true);
                            el.toggleClass("state_problem", false);
                            msg = MESSAGE_DONE + " (" + d + "%)";
                        } else {
                            el.toggleClass("state_progress", true);
                            el.toggleClass("state_done", false);
                            el.toggleClass("state_problem", false);
                            msg = MESSAGE_PROGRESS + " (" + d + "%)";;
                        }
                    }
                }

                if (msg != "") {
                    el.attr("tiptitle", msg);
                    el.qtip({
                        position: { target: 'mouse', adjust: { x: 5, y: 5 } },
                        style: { classes: 'qtip-blue qtip-shadow' },
                        content: { attr: 'tiptitle' },
                        show: { event: "mouseenter" }
                    });
                }

            } else {
                el.toggleClass("state_progress", false);
                el.toggleClass("state_done", false);
                el.toggleClass("state_problem", false);
            }

            if (el.attr("uxid") == SITE_UXID) {
                // it's the site the user is currently viewing, activate timer color scheme
                var a;
                var cfound = false;
                for (a = 0; a < timerColors.length; a++) {
                    if (timerColors[a][0] == SITE_UXID) {
                        cfound = true;
                        timerColors[a][1] = el;
                        timerColors[a][2] = el.css("color");
                    }
                }
                if (!cfound) {
                    n = timerColors.length;
                    timerColors[n] = [ SITE_UXID, el, el.css("color") ];
                }
            }
        });
    }
  }
}

function globalTimerHandler() {
    var j;
    timerIterator++;
    if (intersite.isActive()) {
        intersite.getObj().history.globalmillis += timerMillis;
        var k;
        var ux = "SITE_" + SITE_UXID;
        for (k = 0; k < intersite.getObj().sites.length; k++) {
            if (intersite.getObj().sites[k].uxid == ux) {
                intersite.getObj().sites[k].millis += timerMillis;
            }
        }
    }
}
